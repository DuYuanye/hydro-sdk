// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'TsIr.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$TsIrTearOff {
  const _$TsIrTearOff();

// ignore: unused_element
  _$FromTsClassPostamble fromTsClassPostamble(
      {@required TsClassPostamble tsClassPostamble}) {
    return _$FromTsClassPostamble(
      tsClassPostamble: tsClassPostamble,
    );
  }

// ignore: unused_element
  _$FromTsClassPreamble fromTsClassPreamble(
      {@required TsClassPreamble tsClassPreamble}) {
    return _$FromTsClassPreamble(
      tsClassPreamble: tsClassPreamble,
    );
  }

// ignore: unused_element
  _$FromTsClassStaticConstFieldDeclarations
      fromTsClassStaticConstFieldDeclarations(
          {@required
              TsClassStaticConstFieldDeclarations
                  tsClassStaticConstFieldDeclarations}) {
    return _$FromTsClassStaticConstFieldDeclarations(
      tsClassStaticConstFieldDeclarations: tsClassStaticConstFieldDeclarations,
    );
  }

// ignore: unused_element
  _$FromTsEnum fromTsEnum({@required TsEnum tsEnum}) {
    return _$FromTsEnum(
      tsEnum: tsEnum,
    );
  }

// ignore: unused_element
  _$FromTsInterface fromTsInterface({@required TsInterface tsInterface}) {
    return _$FromTsInterface(
      tsInterface: tsInterface,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $TsIr = _$TsIrTearOff();

/// @nodoc
mixin _$TsIr {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    @required Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            TsClassStaticConstFieldDeclarations
                tsClassStaticConstFieldDeclarations),
    @required Result fromTsEnum(TsEnum tsEnum),
    @required Result fromTsInterface(TsInterface tsInterface),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    Result fromTsClassStaticConstFieldDeclarations(
        TsClassStaticConstFieldDeclarations
            tsClassStaticConstFieldDeclarations),
    Result fromTsEnum(TsEnum tsEnum),
    Result fromTsInterface(TsInterface tsInterface),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fromTsClassPostamble(_$FromTsClassPostamble value),
    @required Result fromTsClassPreamble(_$FromTsClassPreamble value),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            _$FromTsClassStaticConstFieldDeclarations value),
    @required Result fromTsEnum(_$FromTsEnum value),
    @required Result fromTsInterface(_$FromTsInterface value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fromTsClassPostamble(_$FromTsClassPostamble value),
    Result fromTsClassPreamble(_$FromTsClassPreamble value),
    Result fromTsClassStaticConstFieldDeclarations(
        _$FromTsClassStaticConstFieldDeclarations value),
    Result fromTsEnum(_$FromTsEnum value),
    Result fromTsInterface(_$FromTsInterface value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $TsIrCopyWith<$Res> {
  factory $TsIrCopyWith(TsIr value, $Res Function(TsIr) then) =
      _$TsIrCopyWithImpl<$Res>;
}

/// @nodoc
class _$TsIrCopyWithImpl<$Res> implements $TsIrCopyWith<$Res> {
  _$TsIrCopyWithImpl(this._value, this._then);

  final TsIr _value;
  // ignore: unused_field
  final $Res Function(TsIr) _then;
}

/// @nodoc
abstract class _$$FromTsClassPostambleCopyWith<$Res> {
  factory _$$FromTsClassPostambleCopyWith(_$FromTsClassPostamble value,
          $Res Function(_$FromTsClassPostamble) then) =
      __$$FromTsClassPostambleCopyWithImpl<$Res>;
  $Res call({TsClassPostamble tsClassPostamble});
}

/// @nodoc
class __$$FromTsClassPostambleCopyWithImpl<$Res>
    extends _$TsIrCopyWithImpl<$Res>
    implements _$$FromTsClassPostambleCopyWith<$Res> {
  __$$FromTsClassPostambleCopyWithImpl(_$FromTsClassPostamble _value,
      $Res Function(_$FromTsClassPostamble) _then)
      : super(_value, (v) => _then(v as _$FromTsClassPostamble));

  @override
  _$FromTsClassPostamble get _value => super._value as _$FromTsClassPostamble;

  @override
  $Res call({
    Object tsClassPostamble = freezed,
  }) {
    return _then(_$FromTsClassPostamble(
      tsClassPostamble: tsClassPostamble == freezed
          ? _value.tsClassPostamble
          : tsClassPostamble as TsClassPostamble,
    ));
  }
}

/// @nodoc
class _$_$FromTsClassPostamble implements _$FromTsClassPostamble {
  _$_$FromTsClassPostamble({@required this.tsClassPostamble})
      : assert(tsClassPostamble != null);

  @override
  final TsClassPostamble tsClassPostamble;

  @override
  String toString() {
    return 'TsIr.fromTsClassPostamble(tsClassPostamble: $tsClassPostamble)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _$FromTsClassPostamble &&
            (identical(other.tsClassPostamble, tsClassPostamble) ||
                const DeepCollectionEquality()
                    .equals(other.tsClassPostamble, tsClassPostamble)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(tsClassPostamble);

  @override
  _$$FromTsClassPostambleCopyWith<_$FromTsClassPostamble> get copyWith =>
      __$$FromTsClassPostambleCopyWithImpl<_$FromTsClassPostamble>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    @required Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            TsClassStaticConstFieldDeclarations
                tsClassStaticConstFieldDeclarations),
    @required Result fromTsEnum(TsEnum tsEnum),
    @required Result fromTsInterface(TsInterface tsInterface),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsClassPostamble(tsClassPostamble);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    Result fromTsClassStaticConstFieldDeclarations(
        TsClassStaticConstFieldDeclarations
            tsClassStaticConstFieldDeclarations),
    Result fromTsEnum(TsEnum tsEnum),
    Result fromTsInterface(TsInterface tsInterface),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsClassPostamble != null) {
      return fromTsClassPostamble(tsClassPostamble);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fromTsClassPostamble(_$FromTsClassPostamble value),
    @required Result fromTsClassPreamble(_$FromTsClassPreamble value),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            _$FromTsClassStaticConstFieldDeclarations value),
    @required Result fromTsEnum(_$FromTsEnum value),
    @required Result fromTsInterface(_$FromTsInterface value),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsClassPostamble(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fromTsClassPostamble(_$FromTsClassPostamble value),
    Result fromTsClassPreamble(_$FromTsClassPreamble value),
    Result fromTsClassStaticConstFieldDeclarations(
        _$FromTsClassStaticConstFieldDeclarations value),
    Result fromTsEnum(_$FromTsEnum value),
    Result fromTsInterface(_$FromTsInterface value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsClassPostamble != null) {
      return fromTsClassPostamble(this);
    }
    return orElse();
  }
}

abstract class _$FromTsClassPostamble implements TsIr {
  factory _$FromTsClassPostamble(
      {@required TsClassPostamble tsClassPostamble}) = _$_$FromTsClassPostamble;

  TsClassPostamble get tsClassPostamble;
  _$$FromTsClassPostambleCopyWith<_$FromTsClassPostamble> get copyWith;
}

/// @nodoc
abstract class _$$FromTsClassPreambleCopyWith<$Res> {
  factory _$$FromTsClassPreambleCopyWith(_$FromTsClassPreamble value,
          $Res Function(_$FromTsClassPreamble) then) =
      __$$FromTsClassPreambleCopyWithImpl<$Res>;
  $Res call({TsClassPreamble tsClassPreamble});
}

/// @nodoc
class __$$FromTsClassPreambleCopyWithImpl<$Res> extends _$TsIrCopyWithImpl<$Res>
    implements _$$FromTsClassPreambleCopyWith<$Res> {
  __$$FromTsClassPreambleCopyWithImpl(
      _$FromTsClassPreamble _value, $Res Function(_$FromTsClassPreamble) _then)
      : super(_value, (v) => _then(v as _$FromTsClassPreamble));

  @override
  _$FromTsClassPreamble get _value => super._value as _$FromTsClassPreamble;

  @override
  $Res call({
    Object tsClassPreamble = freezed,
  }) {
    return _then(_$FromTsClassPreamble(
      tsClassPreamble: tsClassPreamble == freezed
          ? _value.tsClassPreamble
          : tsClassPreamble as TsClassPreamble,
    ));
  }
}

/// @nodoc
class _$_$FromTsClassPreamble implements _$FromTsClassPreamble {
  _$_$FromTsClassPreamble({@required this.tsClassPreamble})
      : assert(tsClassPreamble != null);

  @override
  final TsClassPreamble tsClassPreamble;

  @override
  String toString() {
    return 'TsIr.fromTsClassPreamble(tsClassPreamble: $tsClassPreamble)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _$FromTsClassPreamble &&
            (identical(other.tsClassPreamble, tsClassPreamble) ||
                const DeepCollectionEquality()
                    .equals(other.tsClassPreamble, tsClassPreamble)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(tsClassPreamble);

  @override
  _$$FromTsClassPreambleCopyWith<_$FromTsClassPreamble> get copyWith =>
      __$$FromTsClassPreambleCopyWithImpl<_$FromTsClassPreamble>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    @required Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            TsClassStaticConstFieldDeclarations
                tsClassStaticConstFieldDeclarations),
    @required Result fromTsEnum(TsEnum tsEnum),
    @required Result fromTsInterface(TsInterface tsInterface),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsClassPreamble(tsClassPreamble);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    Result fromTsClassStaticConstFieldDeclarations(
        TsClassStaticConstFieldDeclarations
            tsClassStaticConstFieldDeclarations),
    Result fromTsEnum(TsEnum tsEnum),
    Result fromTsInterface(TsInterface tsInterface),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsClassPreamble != null) {
      return fromTsClassPreamble(tsClassPreamble);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fromTsClassPostamble(_$FromTsClassPostamble value),
    @required Result fromTsClassPreamble(_$FromTsClassPreamble value),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            _$FromTsClassStaticConstFieldDeclarations value),
    @required Result fromTsEnum(_$FromTsEnum value),
    @required Result fromTsInterface(_$FromTsInterface value),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsClassPreamble(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fromTsClassPostamble(_$FromTsClassPostamble value),
    Result fromTsClassPreamble(_$FromTsClassPreamble value),
    Result fromTsClassStaticConstFieldDeclarations(
        _$FromTsClassStaticConstFieldDeclarations value),
    Result fromTsEnum(_$FromTsEnum value),
    Result fromTsInterface(_$FromTsInterface value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsClassPreamble != null) {
      return fromTsClassPreamble(this);
    }
    return orElse();
  }
}

abstract class _$FromTsClassPreamble implements TsIr {
  factory _$FromTsClassPreamble({@required TsClassPreamble tsClassPreamble}) =
      _$_$FromTsClassPreamble;

  TsClassPreamble get tsClassPreamble;
  _$$FromTsClassPreambleCopyWith<_$FromTsClassPreamble> get copyWith;
}

/// @nodoc
abstract class _$$FromTsClassStaticConstFieldDeclarationsCopyWith<$Res> {
  factory _$$FromTsClassStaticConstFieldDeclarationsCopyWith(
          _$FromTsClassStaticConstFieldDeclarations value,
          $Res Function(_$FromTsClassStaticConstFieldDeclarations) then) =
      __$$FromTsClassStaticConstFieldDeclarationsCopyWithImpl<$Res>;
  $Res call(
      {TsClassStaticConstFieldDeclarations
          tsClassStaticConstFieldDeclarations});
}

/// @nodoc
class __$$FromTsClassStaticConstFieldDeclarationsCopyWithImpl<$Res>
    extends _$TsIrCopyWithImpl<$Res>
    implements _$$FromTsClassStaticConstFieldDeclarationsCopyWith<$Res> {
  __$$FromTsClassStaticConstFieldDeclarationsCopyWithImpl(
      _$FromTsClassStaticConstFieldDeclarations _value,
      $Res Function(_$FromTsClassStaticConstFieldDeclarations) _then)
      : super(_value,
            (v) => _then(v as _$FromTsClassStaticConstFieldDeclarations));

  @override
  _$FromTsClassStaticConstFieldDeclarations get _value =>
      super._value as _$FromTsClassStaticConstFieldDeclarations;

  @override
  $Res call({
    Object tsClassStaticConstFieldDeclarations = freezed,
  }) {
    return _then(_$FromTsClassStaticConstFieldDeclarations(
      tsClassStaticConstFieldDeclarations:
          tsClassStaticConstFieldDeclarations == freezed
              ? _value.tsClassStaticConstFieldDeclarations
              : tsClassStaticConstFieldDeclarations
                  as TsClassStaticConstFieldDeclarations,
    ));
  }
}

/// @nodoc
class _$_$FromTsClassStaticConstFieldDeclarations
    implements _$FromTsClassStaticConstFieldDeclarations {
  _$_$FromTsClassStaticConstFieldDeclarations(
      {@required this.tsClassStaticConstFieldDeclarations})
      : assert(tsClassStaticConstFieldDeclarations != null);

  @override
  final TsClassStaticConstFieldDeclarations tsClassStaticConstFieldDeclarations;

  @override
  String toString() {
    return 'TsIr.fromTsClassStaticConstFieldDeclarations(tsClassStaticConstFieldDeclarations: $tsClassStaticConstFieldDeclarations)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _$FromTsClassStaticConstFieldDeclarations &&
            (identical(other.tsClassStaticConstFieldDeclarations,
                    tsClassStaticConstFieldDeclarations) ||
                const DeepCollectionEquality().equals(
                    other.tsClassStaticConstFieldDeclarations,
                    tsClassStaticConstFieldDeclarations)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(tsClassStaticConstFieldDeclarations);

  @override
  _$$FromTsClassStaticConstFieldDeclarationsCopyWith<
          _$FromTsClassStaticConstFieldDeclarations>
      get copyWith => __$$FromTsClassStaticConstFieldDeclarationsCopyWithImpl<
          _$FromTsClassStaticConstFieldDeclarations>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    @required Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            TsClassStaticConstFieldDeclarations
                tsClassStaticConstFieldDeclarations),
    @required Result fromTsEnum(TsEnum tsEnum),
    @required Result fromTsInterface(TsInterface tsInterface),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsClassStaticConstFieldDeclarations(
        tsClassStaticConstFieldDeclarations);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    Result fromTsClassStaticConstFieldDeclarations(
        TsClassStaticConstFieldDeclarations
            tsClassStaticConstFieldDeclarations),
    Result fromTsEnum(TsEnum tsEnum),
    Result fromTsInterface(TsInterface tsInterface),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsClassStaticConstFieldDeclarations != null) {
      return fromTsClassStaticConstFieldDeclarations(
          tsClassStaticConstFieldDeclarations);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fromTsClassPostamble(_$FromTsClassPostamble value),
    @required Result fromTsClassPreamble(_$FromTsClassPreamble value),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            _$FromTsClassStaticConstFieldDeclarations value),
    @required Result fromTsEnum(_$FromTsEnum value),
    @required Result fromTsInterface(_$FromTsInterface value),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsClassStaticConstFieldDeclarations(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fromTsClassPostamble(_$FromTsClassPostamble value),
    Result fromTsClassPreamble(_$FromTsClassPreamble value),
    Result fromTsClassStaticConstFieldDeclarations(
        _$FromTsClassStaticConstFieldDeclarations value),
    Result fromTsEnum(_$FromTsEnum value),
    Result fromTsInterface(_$FromTsInterface value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsClassStaticConstFieldDeclarations != null) {
      return fromTsClassStaticConstFieldDeclarations(this);
    }
    return orElse();
  }
}

abstract class _$FromTsClassStaticConstFieldDeclarations implements TsIr {
  factory _$FromTsClassStaticConstFieldDeclarations(
          {@required
              TsClassStaticConstFieldDeclarations
                  tsClassStaticConstFieldDeclarations}) =
      _$_$FromTsClassStaticConstFieldDeclarations;

  TsClassStaticConstFieldDeclarations get tsClassStaticConstFieldDeclarations;
  _$$FromTsClassStaticConstFieldDeclarationsCopyWith<
      _$FromTsClassStaticConstFieldDeclarations> get copyWith;
}

/// @nodoc
abstract class _$$FromTsEnumCopyWith<$Res> {
  factory _$$FromTsEnumCopyWith(
          _$FromTsEnum value, $Res Function(_$FromTsEnum) then) =
      __$$FromTsEnumCopyWithImpl<$Res>;
  $Res call({TsEnum tsEnum});
}

/// @nodoc
class __$$FromTsEnumCopyWithImpl<$Res> extends _$TsIrCopyWithImpl<$Res>
    implements _$$FromTsEnumCopyWith<$Res> {
  __$$FromTsEnumCopyWithImpl(
      _$FromTsEnum _value, $Res Function(_$FromTsEnum) _then)
      : super(_value, (v) => _then(v as _$FromTsEnum));

  @override
  _$FromTsEnum get _value => super._value as _$FromTsEnum;

  @override
  $Res call({
    Object tsEnum = freezed,
  }) {
    return _then(_$FromTsEnum(
      tsEnum: tsEnum == freezed ? _value.tsEnum : tsEnum as TsEnum,
    ));
  }
}

/// @nodoc
class _$_$FromTsEnum implements _$FromTsEnum {
  _$_$FromTsEnum({@required this.tsEnum}) : assert(tsEnum != null);

  @override
  final TsEnum tsEnum;

  @override
  String toString() {
    return 'TsIr.fromTsEnum(tsEnum: $tsEnum)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _$FromTsEnum &&
            (identical(other.tsEnum, tsEnum) ||
                const DeepCollectionEquality().equals(other.tsEnum, tsEnum)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(tsEnum);

  @override
  _$$FromTsEnumCopyWith<_$FromTsEnum> get copyWith =>
      __$$FromTsEnumCopyWithImpl<_$FromTsEnum>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    @required Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            TsClassStaticConstFieldDeclarations
                tsClassStaticConstFieldDeclarations),
    @required Result fromTsEnum(TsEnum tsEnum),
    @required Result fromTsInterface(TsInterface tsInterface),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsEnum(tsEnum);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    Result fromTsClassStaticConstFieldDeclarations(
        TsClassStaticConstFieldDeclarations
            tsClassStaticConstFieldDeclarations),
    Result fromTsEnum(TsEnum tsEnum),
    Result fromTsInterface(TsInterface tsInterface),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsEnum != null) {
      return fromTsEnum(tsEnum);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fromTsClassPostamble(_$FromTsClassPostamble value),
    @required Result fromTsClassPreamble(_$FromTsClassPreamble value),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            _$FromTsClassStaticConstFieldDeclarations value),
    @required Result fromTsEnum(_$FromTsEnum value),
    @required Result fromTsInterface(_$FromTsInterface value),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsEnum(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fromTsClassPostamble(_$FromTsClassPostamble value),
    Result fromTsClassPreamble(_$FromTsClassPreamble value),
    Result fromTsClassStaticConstFieldDeclarations(
        _$FromTsClassStaticConstFieldDeclarations value),
    Result fromTsEnum(_$FromTsEnum value),
    Result fromTsInterface(_$FromTsInterface value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsEnum != null) {
      return fromTsEnum(this);
    }
    return orElse();
  }
}

abstract class _$FromTsEnum implements TsIr {
  factory _$FromTsEnum({@required TsEnum tsEnum}) = _$_$FromTsEnum;

  TsEnum get tsEnum;
  _$$FromTsEnumCopyWith<_$FromTsEnum> get copyWith;
}

/// @nodoc
abstract class _$$FromTsInterfaceCopyWith<$Res> {
  factory _$$FromTsInterfaceCopyWith(
          _$FromTsInterface value, $Res Function(_$FromTsInterface) then) =
      __$$FromTsInterfaceCopyWithImpl<$Res>;
  $Res call({TsInterface tsInterface});
}

/// @nodoc
class __$$FromTsInterfaceCopyWithImpl<$Res> extends _$TsIrCopyWithImpl<$Res>
    implements _$$FromTsInterfaceCopyWith<$Res> {
  __$$FromTsInterfaceCopyWithImpl(
      _$FromTsInterface _value, $Res Function(_$FromTsInterface) _then)
      : super(_value, (v) => _then(v as _$FromTsInterface));

  @override
  _$FromTsInterface get _value => super._value as _$FromTsInterface;

  @override
  $Res call({
    Object tsInterface = freezed,
  }) {
    return _then(_$FromTsInterface(
      tsInterface: tsInterface == freezed
          ? _value.tsInterface
          : tsInterface as TsInterface,
    ));
  }
}

/// @nodoc
class _$_$FromTsInterface implements _$FromTsInterface {
  _$_$FromTsInterface({@required this.tsInterface})
      : assert(tsInterface != null);

  @override
  final TsInterface tsInterface;

  @override
  String toString() {
    return 'TsIr.fromTsInterface(tsInterface: $tsInterface)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _$FromTsInterface &&
            (identical(other.tsInterface, tsInterface) ||
                const DeepCollectionEquality()
                    .equals(other.tsInterface, tsInterface)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(tsInterface);

  @override
  _$$FromTsInterfaceCopyWith<_$FromTsInterface> get copyWith =>
      __$$FromTsInterfaceCopyWithImpl<_$FromTsInterface>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    @required Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            TsClassStaticConstFieldDeclarations
                tsClassStaticConstFieldDeclarations),
    @required Result fromTsEnum(TsEnum tsEnum),
    @required Result fromTsInterface(TsInterface tsInterface),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsInterface(tsInterface);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fromTsClassPostamble(TsClassPostamble tsClassPostamble),
    Result fromTsClassPreamble(TsClassPreamble tsClassPreamble),
    Result fromTsClassStaticConstFieldDeclarations(
        TsClassStaticConstFieldDeclarations
            tsClassStaticConstFieldDeclarations),
    Result fromTsEnum(TsEnum tsEnum),
    Result fromTsInterface(TsInterface tsInterface),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsInterface != null) {
      return fromTsInterface(tsInterface);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fromTsClassPostamble(_$FromTsClassPostamble value),
    @required Result fromTsClassPreamble(_$FromTsClassPreamble value),
    @required
        Result fromTsClassStaticConstFieldDeclarations(
            _$FromTsClassStaticConstFieldDeclarations value),
    @required Result fromTsEnum(_$FromTsEnum value),
    @required Result fromTsInterface(_$FromTsInterface value),
  }) {
    assert(fromTsClassPostamble != null);
    assert(fromTsClassPreamble != null);
    assert(fromTsClassStaticConstFieldDeclarations != null);
    assert(fromTsEnum != null);
    assert(fromTsInterface != null);
    return fromTsInterface(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fromTsClassPostamble(_$FromTsClassPostamble value),
    Result fromTsClassPreamble(_$FromTsClassPreamble value),
    Result fromTsClassStaticConstFieldDeclarations(
        _$FromTsClassStaticConstFieldDeclarations value),
    Result fromTsEnum(_$FromTsEnum value),
    Result fromTsInterface(_$FromTsInterface value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fromTsInterface != null) {
      return fromTsInterface(this);
    }
    return orElse();
  }
}

abstract class _$FromTsInterface implements TsIr {
  factory _$FromTsInterface({@required TsInterface tsInterface}) =
      _$_$FromTsInterface;

  TsInterface get tsInterface;
  _$$FromTsInterfaceCopyWith<_$FromTsInterface> get copyWith;
}
